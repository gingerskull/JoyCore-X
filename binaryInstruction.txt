Introduction
This document explains how JoyCore-FW (branch rp2040-dev) persists joystick configuration on RP2040 boards using a tiny EEPROM‑emulated file system. It details the binary layout of /config.bin, the load/save/backup logic, how writes propagate into runtime behavior, and how to safely delete or format storage. An external application (another AI or host utility) can use this to implement read/modify/write cycles, resets, or recovery tooling.

Key Source Files (raw links)
Storage abstraction and implementation:

StorageInterface.h
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/StorageInterface.h
RP2040EEPROMStorage.h / .cpp
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/rp2040/storage/RP2040EEPROMStorage.h
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/rp2040/storage/RP2040EEPROMStorage.cpp
Configuration system:

ConfigManager.h / .cpp
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/core/ConfigManager.h
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/core/ConfigManager.cpp
ConfigStructs.h (binary layout)
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/core/ConfigStructs.h
ConfigMode.h (filenames, flags)
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/core/ConfigMode.h
Static default sources (only used when generating an initial config):

ConfigDigital.h
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/ConfigDigital.h
ConfigAxis.h
https://raw.githubusercontent.com/gingerskull/JoyCore-FW/rp2040-dev/src/config/ConfigAxis.h
Filenames and Their Roles
/config.bin (primary serialized configuration) → key "CFG"
/config_backup.bin (last good backup) → key "BAK"
/fw_version.txt (firmware semantic version string) → key "VER"
Storage Layer Overview
Emulated EEPROM: 4096 bytes total.
Layout (RP2040EEPROMStorage):

0x0000–0x003F (64 bytes): file table (up to 8 entries)
0x0040–0x0FFF: data region (4032 bytes)
File entry: 8 bytes (name[4], offset(uint16), size(uint16)).
Allocation: first‑fit; removal leaves reusable gaps (no compaction).
Writes: in-place if new payload fits existing space; otherwise allocate new region and update table.

Public / Semi-Public APIs
From StorageInterface / RP2040EEPROMStorage:

initialize()
read(filename, buffer, size, &bytesRead)
write(filename, data, size)
exists(filename)
remove(filename)
listFiles(char names[][32], max)
format()
getUsedSpace(), getAvailableSpace()
From ConfigManager (when CONFIG_FEATURE_STORAGE_ENABLED):

initialize()
loadConfiguration() (normally handled internally)
saveConfiguration()
resetToDefaults() (regenerates defaults + save)
formatStorage() (wrapper around storage.format())
readFile/writeFile/listStorageFiles/debugStorage() (No direct exposed remove wrapper—can be added; otherwise call lower-level storage.)
Binary Layout of /config.bin
StoredConfig (fixed portion):

ConfigHeader
magic = 0x4A4F5943 ("JOYC")
version = CONFIG_VERSION (see ConfigMode.h)
size = total serialized byte count (fixed + variable section)
checksum = CRC32 over serialized config (StoredConfig + variable data; see implementation)
StoredUSBDescriptor
Counts: pinMapCount (uint8), logicalInputCount (uint8), shiftRegCount (uint8), padding
8 × StoredAxisConfig (15 bytes each; packing enforced by static_assert)
Variable section (immediately follows):

pinMapCount × StoredPinMapEntry
logicalInputCount × StoredLogicalInput
Checksum must match firmware calculation; external tooling must replicate algorithm precisely (see ConfigConversion::calculateChecksum in ConfigConversion.cpp).

Load Flow (Boot)
ConfigManager::initialize()
Storage init (RP2040EEPROMStorage::initialize/EEPROM.begin)
Firmware version check (checkAndUpdateFirmwareVersion):
If /fw_version.txt differs → rewrite version file only
loadConfiguration(): a. loadFromStorage(): read /config.bin, validate magic, size, counts, checksum
b. If not found or invalid → restoreFromBackup() then retry
c. If still invalid → generate defaults from static headers → saveToStorage()
Once /config.bin loads successfully, runtime joystick behavior uses the in-memory structures populated from it; static headers are ignored until a regeneration path is triggered (format/reset/missing file).

Save Flow
saveConfiguration() → saveToStorage():

Serialize current runtime state (getSerializedConfig)
createBackup(): copy /config.bin → /config_backup.bin (if primary exists)
write new /config.bin (StorageInterface::write)
Commit (EEPROM commit inside RP2040EEPROMStorage)
Delete / Remove / Format Behavior
remove(filename): Low-level deletion. Clears file table entry; data region remains untouched (hole reused by allocator).
There is no direct high-level API to remove just /config.bin in ConfigManager; you can expose one or call storage.remove("/config.bin") via an extension.
format():
Overwrites all 4096 bytes (writes 0xFF)
Resets file table (all entries zeroed)
Empties file list (effectively deletes every file: config, backup, version)
Next boot: no /config.bin → defaults regenerated → new /config.bin + /fw_version.txt
resetToDefaults():
Regenerates in-memory defaults (like first-time path)
Saves them to /config.bin (backup created beforehand if one existed)
Does NOT delete other files (e.g., firmware version)
When to choose which:

Remove only /config.bin: forces regeneration while preserving /fw_version.txt (so version stays, but defaults generated).
resetToDefaults(): preserves version, overwrites config file immediately with defaults (clean and safer).
format(): nuclear option; clears all—useful for corruption scenarios or wanting pristine environment.
Failure & Fallback Chain
Primary read (/config.bin) fails → Attempt restore from backup (/config_backup.bin) → If restore success, retry load → If still failing (or backup missing), generate defaults → save new /config.bin (backup overwritten next save) → write /fw_version.txt if absent.

Validation checks include:

Magic number
Version (must match CONFIG_VERSION; mismatches make validation fail)
Size bounds (not exceeding buffer or structural expectations)
CRC32 checksum
Count sanity (within MAX_* constants)
External Tooling Workflow (Recommended)
Read-modify-write cycle:
ok
Read /config.bin (if you expose serial command that proxies readFile)
Parse header & counts; validate checksum and size before trusting
Modify desired structures (e.g., enable axis, adjust pins, change button mapping)
Reconstruct variable section; recompute checksum; update header.size & checksume
Write new /config.bin atomically (optionally ask firmware to create backup then replace—current firmware already does backup internally on saveToStorage())
Trigger a reload:
Option A: Reboot device (simplest)
Option B: Implement a serial command that calls g_configManager.loadConfiguration()
Option C: Implement applyConfiguration() path (already declared) followed by saveConfiguration()
Creating a fresh default:

Either call resetToDefaults()
Or remove /config.bin and reboot (if you add remove capability)
Hard reset:

formatStorage() (then reboot) → full regeneration path.
Constraints & Limits
Buffer size in load/save code: 2048 bytes (practical cap for serialized config)
Max pinMapCount: 32
Max logicalInputCount: 64
Fixed axes: 8 (struct array always present)
StoredAxisConfig size enforced (15 bytes) — ABI drift will assert/fail compile
Total EEPROM data region: 4032 bytes; current config footprint is typically well under this.
Edge Cases
Fragmentation: Very unlikely given few small files; format() resolves worst-case.
Version change: Only updates /fw_version.txt; does NOT regenerate config.
Removing only /fw_version.txt: Next boot writes it again; no impact on config content.
Suggested Extensions for External Integration
(These are not yet in repo; safe to add)

Serial command: LIST (listStorageFiles)
Serial command: READ <filename> (stream raw bytes Base64 or hex)
Serial command: WRITE <filename> <length> <payload>
Serial command: DELETE <filename> (calls remove)
Serial command: FORMAT (formatStorage)
Serial command: RESET_DEFAULTS (resetToDefaults)
Serial command: STATUS (getStatus + maybe computed CRC)
Serial command: RELOAD (loadConfiguration without reboot)
Headers vs Stored Configuration
Once /config.bin exists and validates, joystick logic reads ONLY runtime structures derived from that file. Edits to ConfigDigital.h / ConfigAxis.h have no effect until config regeneration (resetToDefaults(), format, or missing file scenario).

Quick Field Reference
Header.magic: 0x4A4F5943
Header.version: CONFIG_VERSION
Header.size: total serialized bytes
Header.checksum: CRC32 (firmware algorithm)
Counts: pinMapCount, logicalInputCount, shiftRegCount
Axes: 8 × StoredAxisConfig (enabled=0 means inactive)
Variable tail: pin map entries then logical inputs

Recovery Scenarios
Corrupt primary, valid backup → automatic restore
Both corrupt → defaults regenerate
Repeated corruption → recommend external tool issue a formatStorage()
Summary
All joystick behavior is driven by a validated, checksummed /config.bin loaded at initialization. A minimal EEPROM file system provides atomic(-ish) updates via backup creation. External tools must replicate the binary layout and checksum to apply updates. Deletion (remove), regeneration (resetToDefaults), and full wipe (format) offer escalating levels of reset control.